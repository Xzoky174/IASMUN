import{s as y,F as d,G as E,H as w,I as O,K as S,o as k,b as q,t as z}from"./scheduler.CY_2In7Q.js";import{S as C,i as D,a as F,t as G}from"./index.bjie8dbU.js";const H=l=>({intersecting:l&1,entry:l&2,observer:l&4}),v=l=>({intersecting:l[0],entry:l[1],observer:l[2]});function K(l){let t;const n=l[9].default,r=d(n,l,l[8],v);return{c(){r&&r.c()},l(s){r&&r.l(s)},m(s,o){r&&r.m(s,o),t=!0},p(s,[o]){r&&r.p&&(!t||o&263)&&E(r,n,s,s[8],t?O(n,s[8],o,H):w(s[8]),v)},i(s){t||(F(r,s),t=!0)},o(s){G(r,s),t=!1},d(s){r&&r.d(s)}}}function R(l,t,n){let{$$slots:r={},$$scope:s}=t,{element:o=null}=t,{once:a=!1}=t,{intersecting:_=!1}=t,{root:g=null}=t,{rootMargin:f="0px"}=t,{threshold:m=0}=t,{entry:c=null}=t,{observer:i=null}=t;const h=S();let b=null,u=null;const I=()=>{n(2,i=new IntersectionObserver(e=>{e.forEach(M=>{n(1,c=M),n(0,_=M.isIntersecting)})},{root:g,rootMargin:f,threshold:m}))};return k(()=>(I(),()=>{i&&(i.disconnect(),n(2,i=null))})),q(async()=>{c!==null&&(h("observe",c),c.isIntersecting&&(h("intersect",c),a&&i.unobserve(o))),await z(),o!==null&&o!==u&&(i.observe(o),u!==null&&i.unobserve(u),u=o),b&&f!==b&&(i.disconnect(),u=null,I()),b=f}),l.$$set=e=>{"element"in e&&n(3,o=e.element),"once"in e&&n(4,a=e.once),"intersecting"in e&&n(0,_=e.intersecting),"root"in e&&n(5,g=e.root),"rootMargin"in e&&n(6,f=e.rootMargin),"threshold"in e&&n(7,m=e.threshold),"entry"in e&&n(1,c=e.entry),"observer"in e&&n(2,i=e.observer),"$$scope"in e&&n(8,s=e.$$scope)},[_,c,i,o,a,g,f,m,s,r]}class A extends C{constructor(t){super(),D(this,t,R,K,y,{element:3,once:4,intersecting:0,root:5,rootMargin:6,threshold:7,entry:1,observer:2})}}export{A as I};
